gcd <- function(a, b) {
a <- abs(a);  b <- abs(b)
while (b != 0L) {
tmp <- b
b   <- a %% b
a   <- tmp
}
a
}
coprimes <- function(n) {
if (n <= 1L) stop("n must be ≥ 2")
Filter(function(g) gcd(g, n) == 1L, 1L:(n - 1L))
}
cyclic_design <- function(n = 37,k = 3, r=3, eta= 2^x) {
if (k < 2L) {stop("k must be ≥ 2")}
if (r > k*length(coprimes(n))) {stop("r must be smaller than k*phi(n)")}
if (r %% k != 0) {
stop("r must be divisible by k.")
}
G  <- coprimes(n)[1:(r/k)]                     # all admissible multipliers (injective case only)
Js <- 0L:(k - 1L)                     # exponents {0,…,k-1}
blocks <- list()
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
attr(blocks, "n") <- n
attr(blocks, "k") <- k
attr(blocks, "multipliers") <- G
k <- length(blocks[[1]])
n_blocks <- length(blocks)
mat <- matrix(NA_integer_, nrow = n_blocks, ncol = k)
for (i in seq_len(n_blocks)) {
mat[i, ] <- blocks[[i]]
}
return(list(blocks, mat))
}
res <- cyclic_design(n = 50,k = 3,r = 3,eta = x)
eta <- 2^x
eta <- function(x) x
eta(5)
eta <- function(x) x
res <- cyclic_design(n = 50,k = 3,r = 3,eta = eta)
dim(res[[1]])
class(res[[1]])
class(res[[2]])
dim(res[[2]])
View(res[[2]])
eta <- function(x) 2^x
res <- cyclic_design(n = 50,k = 3,r = 3,eta = eta)
View(res[[2]])
View(res[[2]]+1)
trial1 <- res[[2]]+1
which(res[[2]]==0)
dim(res[[2]])
eta <- function(x) 2^x
res <- cyclic_design(n = 50,k = 3,r = 9,eta = eta)
View(res[[2]])
View(res[[2]]+1)
n
n <- 50
k <- 3
r <- 9
eta
G  <- coprimes(n)[1:(r/k)]                     # all admissible multipliers (injective case only)
n
Js <- 0L:(k - 1L)                     # exponents {0,…,k-1}
blocks <- list()
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
attr(blocks, "n") <- n
attr(blocks, "k") <- k
attr(blocks, "multipliers") <- G
length(blocks)
blocks[[1]]
blocks[[2]]
blocks[[3]]
blocks[blocks == 0] <- n
str(blocks)
class(blocks)
blocks <- list()
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
blocks[blocks == 0] <- n
Js <- 0L:(k - 1L)                     # exponents {0,…,k-1}
blocks <- list()
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
attr(blocks, "n") <- n
attr(blocks, "k") <- k
attr(blocks, "multipliers") <- G
k <- length(blocks[[1]])
n_blocks <- length(blocks)
# replace zeros with n
blocks <- lapply(blocks, function(x) x[x == 0] <- n)
blocks[[1]]
blocks[[2]]
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
attr(blocks, "n") <- n
attr(blocks, "k") <- k
attr(blocks, "multipliers") <- G
k <- length(blocks[[1]])
n_blocks <- length(blocks)
blocks[[1]]
blocks[[2]]
n
# replace zeros with n
blocks <- lapply(blocks, function(x) x[which(x == 0)] <- n)
length(blocks)
blocks[[1]]
blocks[[2]]
blocks[[1]]
blocks <- list()
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
attr(blocks, "n") <- n
attr(blocks, "k") <- k
attr(blocks, "multipliers") <- G
k <- length(blocks[[1]])
n_blocks <- length(blocks)
blocks[[1]]
blocks[[1]][which(blocks[[1]]== 0)]
blocks[[1]][which(blocks[[1]]== "0")]
which(blocks[[1]]== 0)
which(blocks[[2]]== 0)
source("C:/Users/Cesare/Desktop/Miglioli/IUstat_equireplicate_designs/sim_study_functions.R", echo=TRUE)
blocks <- list()
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
attr(blocks, "n") <- n
attr(blocks, "k") <- k
attr(blocks, "multipliers") <- G
k <- length(blocks[[1]])
n_blocks <- length(blocks)
blocks[[1]]
# replace zeros with n
blocks <- lapply(blocks, function(x) replace(x, x == 0, n))
blocks[[1]]
blocks[[2]]
blocks[[50]]
blocks[[49]]
blocks[[48]]
n
length(blocks)
mat <- matrix(NA_integer_, nrow = n_blocks, ncol = k)
for (i in seq_len(n_blocks)) {
mat[i, ] <- blocks[[i]]
}
View(mat)
rm(list = ls())
randes_full_k2 <- function(n, B) {
idx <- sample(choose(n, 2), B)           # choose B columns
t(combn(n, 2, simplify = TRUE)[, idx])   # each column is an unordered pair
}
gcd <- function(a, b) {
a <- abs(a);  b <- abs(b)
while (b != 0L) {
tmp <- b
b   <- a %% b
a   <- tmp
}
a
}
coprimes <- function(n) {
if (n <= 1L) stop("n must be ≥ 2")
Filter(function(g) gcd(g, n) == 1L, 1L:(n - 1L))
}
cyclic_design <- function(n = 37,k = 3, r=3, eta= 2^x) {
if (k < 2L) {stop("k must be ≥ 2")}
if (r > k*length(coprimes(n))) {stop("r must be smaller than k*phi(n)")}
if (r %% k != 0) {
stop("r must be divisible by k.")
}
G  <- coprimes(n)[1:(r/k)]                     # all admissible multipliers (injective case only)
Js <- 0L:(k - 1L)                     # exponents {0,…,k-1}
blocks <- list()
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
attr(blocks, "n") <- n
attr(blocks, "k") <- k
attr(blocks, "multipliers") <- G
k <- length(blocks[[1]])
n_blocks <- length(blocks)
# replace zeros with n
blocks <- lapply(blocks, function(x) replace(x, x == 0, n))
mat <- matrix(NA_integer_, nrow = n_blocks, ncol = k)
for (i in seq_len(n_blocks)) {
mat[i, ] <- blocks[[i]]
}
return(list(blocks, mat))
}
eta <- function(x) 2^x
res <- cyclic_design(n = 50,k = 3,r = 9,eta = eta)
view(res[[2]])
View(res[[2]])
