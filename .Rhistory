gcd <- function(a, b) {
a <- abs(a);  b <- abs(b)
while (b != 0L) {
tmp <- b
b   <- a %% b
a   <- tmp
}
a
}
coprimes <- function(n) {
if (n <= 1L) stop("n must be ≥ 2")
Filter(function(g) gcd(g, n) == 1L, 1L:(n - 1L))
}
cyclic_design <- function(n = 37,k = 3, r=3, eta= 2^x) {
if (k < 2L) {stop("k must be ≥ 2")}
if (r > k*length(coprimes(n))) {stop("r must be smaller than k*phi(n)")}
if (r %% k != 0) {
stop("r must be divisible by k.")
}
G  <- coprimes(n)[1:(r/k)]                     # all admissible multipliers (injective case only)
Js <- 0L:(k - 1L)                     # exponents {0,…,k-1}
blocks <- list()
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
attr(blocks, "n") <- n
attr(blocks, "k") <- k
attr(blocks, "multipliers") <- G
k <- length(blocks[[1]])
n_blocks <- length(blocks)
mat <- matrix(NA_integer_, nrow = n_blocks, ncol = k)
for (i in seq_len(n_blocks)) {
mat[i, ] <- blocks[[i]]
}
return(list(blocks, mat))
}
res <- cyclic_design(n = 50,k = 3,r = 3,eta = x)
eta <- 2^x
eta <- function(x) x
eta(5)
eta <- function(x) x
res <- cyclic_design(n = 50,k = 3,r = 3,eta = eta)
dim(res[[1]])
class(res[[1]])
class(res[[2]])
dim(res[[2]])
View(res[[2]])
eta <- function(x) 2^x
res <- cyclic_design(n = 50,k = 3,r = 3,eta = eta)
View(res[[2]])
View(res[[2]]+1)
trial1 <- res[[2]]+1
which(res[[2]]==0)
dim(res[[2]])
eta <- function(x) 2^x
res <- cyclic_design(n = 50,k = 3,r = 9,eta = eta)
View(res[[2]])
View(res[[2]]+1)
n
n <- 50
k <- 3
r <- 9
eta
G  <- coprimes(n)[1:(r/k)]                     # all admissible multipliers (injective case only)
n
Js <- 0L:(k - 1L)                     # exponents {0,…,k-1}
blocks <- list()
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
attr(blocks, "n") <- n
attr(blocks, "k") <- k
attr(blocks, "multipliers") <- G
length(blocks)
blocks[[1]]
blocks[[2]]
blocks[[3]]
blocks[blocks == 0] <- n
str(blocks)
class(blocks)
blocks <- list()
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
blocks[blocks == 0] <- n
Js <- 0L:(k - 1L)                     # exponents {0,…,k-1}
blocks <- list()
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
attr(blocks, "n") <- n
attr(blocks, "k") <- k
attr(blocks, "multipliers") <- G
k <- length(blocks[[1]])
n_blocks <- length(blocks)
# replace zeros with n
blocks <- lapply(blocks, function(x) x[x == 0] <- n)
blocks[[1]]
blocks[[2]]
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
attr(blocks, "n") <- n
attr(blocks, "k") <- k
attr(blocks, "multipliers") <- G
k <- length(blocks[[1]])
n_blocks <- length(blocks)
blocks[[1]]
blocks[[2]]
n
# replace zeros with n
blocks <- lapply(blocks, function(x) x[which(x == 0)] <- n)
length(blocks)
blocks[[1]]
blocks[[2]]
blocks[[1]]
blocks <- list()
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
attr(blocks, "n") <- n
attr(blocks, "k") <- k
attr(blocks, "multipliers") <- G
k <- length(blocks[[1]])
n_blocks <- length(blocks)
blocks[[1]]
blocks[[1]][which(blocks[[1]]== 0)]
blocks[[1]][which(blocks[[1]]== "0")]
which(blocks[[1]]== 0)
which(blocks[[2]]== 0)
source("C:/Users/Cesare/Desktop/Miglioli/IUstat_equireplicate_designs/sim_study_functions.R", echo=TRUE)
blocks <- list()
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
attr(blocks, "n") <- n
attr(blocks, "k") <- k
attr(blocks, "multipliers") <- G
k <- length(blocks[[1]])
n_blocks <- length(blocks)
blocks[[1]]
# replace zeros with n
blocks <- lapply(blocks, function(x) replace(x, x == 0, n))
blocks[[1]]
blocks[[2]]
blocks[[50]]
blocks[[49]]
blocks[[48]]
n
length(blocks)
mat <- matrix(NA_integer_, nrow = n_blocks, ncol = k)
for (i in seq_len(n_blocks)) {
mat[i, ] <- blocks[[i]]
}
View(mat)
rm(list = ls())
randes_full_k2 <- function(n, B) {
idx <- sample(choose(n, 2), B)           # choose B columns
t(combn(n, 2, simplify = TRUE)[, idx])   # each column is an unordered pair
}
gcd <- function(a, b) {
a <- abs(a);  b <- abs(b)
while (b != 0L) {
tmp <- b
b   <- a %% b
a   <- tmp
}
a
}
coprimes <- function(n) {
if (n <= 1L) stop("n must be ≥ 2")
Filter(function(g) gcd(g, n) == 1L, 1L:(n - 1L))
}
cyclic_design <- function(n = 37,k = 3, r=3, eta= 2^x) {
if (k < 2L) {stop("k must be ≥ 2")}
if (r > k*length(coprimes(n))) {stop("r must be smaller than k*phi(n)")}
if (r %% k != 0) {
stop("r must be divisible by k.")
}
G  <- coprimes(n)[1:(r/k)]                     # all admissible multipliers (injective case only)
Js <- 0L:(k - 1L)                     # exponents {0,…,k-1}
blocks <- list()
blk_id <- 1L
for (g in G) {
for (i in 0L:(n - 1L)) {
block <- (i + g * (eta(Js) - eta(0))) %% n
blocks[[blk_id]] <- block
blk_id <- blk_id + 1L
}
}
attr(blocks, "n") <- n
attr(blocks, "k") <- k
attr(blocks, "multipliers") <- G
k <- length(blocks[[1]])
n_blocks <- length(blocks)
# replace zeros with n
blocks <- lapply(blocks, function(x) replace(x, x == 0, n))
mat <- matrix(NA_integer_, nrow = n_blocks, ncol = k)
for (i in seq_len(n_blocks)) {
mat[i, ] <- blocks[[i]]
}
return(list(blocks, mat))
}
eta <- function(x) 2^x
res <- cyclic_design(n = 50,k = 3,r = 9,eta = eta)
view(res[[2]])
View(res[[2]])
# 0) Download & extract (skip if already present)
base_url <- "https://www.cs.toronto.edu/~kriz/cifar-10-binary.tar.gz"
tgz <- "cifar-10-binary.tar.gz"
out_dir <- "cifar10_bin"
if (!dir.exists(out_dir)) {
if (!file.exists(tgz)) download.file(base_url, tgz, mode = "wb")
untar(tgz, exdir = out_dir)
}
# 1) Reader for one CIFAR-10 binary batch (returns flat X and labels y)
read_cifar10_flat <- function(path) {
con <- file(path, "rb"); on.exit(close(con))
bytes_per_img <- 1L + 3072L
raw <- readBin(con, what = "raw", n = file.info(path)$size)
n   <- length(raw) / bytes_per_img
stopifnot(n == floor(n))
M   <- matrix(as.integer(raw), ncol = bytes_per_img, byrow = TRUE)
y   <- as.integer(M[, 1])
X   <- matrix(as.numeric(M[, -1, drop = FALSE]), nrow = n)  # n x 3072
list(X = X, y = y)
}
# 2) Load all 5 train batches + test into one big (n x 3072) and labels
batch_files <- file.path(out_dir, "cifar-10-batches-bin",
c(sprintf("data_batch_%d.bin", 1:5), "test_batch.bin")
)
parts <- lapply(batch_files, read_cifar10_flat)
X_all <- do.call(rbind, lapply(parts, `[[`, "X"))   # 60000 x 3072
y_all <- unlist(lapply(parts, `[[`, "y"), use.names = FALSE)  # length 60000
# 3) Pixel scaling + feature standardization (robust defaults for Gaussian MMD)
#    - Scale pixel intensities to [0,1]
#    - Z-score each column: (x - mean) / sd, with small epsilon guard
X_scaled <- X_all / 255
mu <- colMeans(X_scaled)
sdv <- sqrt(pmax(colMeans((X_scaled - rep(mu, each = nrow(X_scaled)))^2), 1e-12))
X_std <- sweep(sweep(X_scaled, 2, mu, `-`), 2, sdv, `/`)  # standardized n x 3072
# 4) Split into per-class matrices P_0..P_9 (each is n_k x 3072), ready for MMD
P_list <- lapply(0:9, function(k) X_std[y_all == k, , drop = FALSE])
names(P_list) <- paste0("P_", 0:9)
# 5) Handy metadata (counts, means/sds used), in case you want to transform other sets the same way
counts <- sapply(P_list, nrow)
list2env(list(P = P_list,
counts = counts,
feature_mean = mu,
feature_sd = sdv),
envir = .GlobalEnv)
class(P$P_0)
rm(list = ls())
base_url <- "https://www.cs.toronto.edu/~kriz/cifar-10-binary.tar.gz"
tgz <- "cifar-10-binary.tar.gz"
out_dir <- "cifar10_bin"
if (!dir.exists(out_dir)) {
if (!file.exists(tgz)) download.file(base_url, tgz, mode = "wb")
untar(tgz, exdir = out_dir)
}
read_cifar10_flat <- function(path) {
con <- file(path, "rb"); on.exit(close(con))
bytes_per_img <- 1L + 3072L
raw <- readBin(con, what = "raw", n = file.info(path)$size)
n   <- length(raw) / bytes_per_img
stopifnot(n == floor(n))
M   <- matrix(as.integer(raw), ncol = bytes_per_img, byrow = TRUE)
y   <- as.integer(M[, 1])
X   <- matrix(as.numeric(M[, -1, drop = FALSE]), nrow = n)  # n x 3072
list(X = X, y = y)
}
batch_files <- file.path(out_dir, "cifar-10-batches-bin",
c(sprintf("data_batch_%d.bin", 1:5), "test_batch.bin")
)
parts <- lapply(batch_files, read_cifar10_flat)
X_all <- do.call(rbind, lapply(parts, `[[`, "X"))   # 60000 x 3072
y_all <- unlist(lapply(parts, `[[`, "y"), use.names = FALSE)  # length 60000
dim(X_all)
X_scaled <- X_all / 255
mu <- colMeans(X_scaled)
sdv <- sqrt(pmax(colMeans((X_scaled - rep(mu, each = nrow(X_scaled)))^2), 1e-12))
X_std <- sweep(sweep(X_scaled, 2, mu, `-`), 2, sdv, `/`)  # standardized n x 3072
P <- lapply(0:9, function(k) X_std[y_all == k, , drop = FALSE])
names(P) <- paste0("P_", 0:9)
class(P)
rm(parts)
rm(X_scaled)
rm(X_all,X_std)
P_new <- P
rm(P)
load("C:/Users/Cesare/Desktop/Cifar10/C10_list.Rdata")
sum(P$P_0 == P_new$P_0)
sum(P$P_0 =! P_new$P_0)
sum(P$P_0 != P_new$P_0)
sum(P$P_1 != P_new$P_0)
sum(P$P_1 == P_new$P_1)
dim(P$P_0)
6000*3072
sum(P$P_2 == P_new$P_2)
sum(P$P_3 == P_new$P_3)
rm(list = ls())
